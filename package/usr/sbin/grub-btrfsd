#!/usr/bin/env bash
# Copyright 2023 Pascal Jaeger
# Distributed under the terms of the GNU General Public License v3
# Update GRUB when new BTRFS snapshots are created.

# shellcheck disable=SC2317
function sigHandler  () {

    trap '""' SIGINT SIGTERM
    vlog "Parent $$: Received signal SIGINT/ SIGTERM"
    kill 0
    wait
    exit 0
}

function log () {
    echo "${2}"$1"${RESET}"
    if [ ${syslog} = true ]; then
          logger -p user.notice -t ${0##*/}"["$$"]" "$1"
    fi
    if [ ${#logfile} -gt 1  ]; then
          echo "$(date) ${1}" >> "${logfile}"
    fi
}

function vlog () {
    if [ ${verbose} = true ]; then
          echo "${2}"$1"${RESET}"
          if [ ${syslog} = true ]; then
                logger -p user.notice -t ${0##*/} "$1"
          fi
          if [ ${#logfile} -gt 1  ]; then
                echo "$(date) ${1}" >> "${logfile}"
          fi
    fi
}

function err () {
    echo "${2}"${1}"${RESET}" >&2
    if [ ${syslog} = true ]; then
          logger -p user.error -t ${0##*/} "$1"
    fi
    if [ ${#logfile} -gt 1  ]; then
          echo "$(date) error: ${1}" >> "${logfile}"
    fi
}

function checks () {
    # check if inotify exists, see issue #227
    if ! command -v inotifywait >/dev/null 2>&1; then
          err "[!] inotifywait was not found, exiting. Is inotify-tools installed?" >&2
          exit 1
    fi

    if [ ${timeshift_auto} = false ] && [ ${timeshift_old} = true ]; then
          err "[!] Flag --timeshift-old requires flag --timeshift-auto" >&2
          exit 1
    fi

    if ! [ ${timeshift_auto} = true ]; then
          for snapdir in "${snapdirs[@]}"
              do
                  if ! [ -d ${snapdir} ]; then
                        err "[!] No directory found at ${snapdir}" >&2
                        err "[!] Please specify a valid snapshot directory" >&2
                        exit 1
                  fi
          done
    fi
}

function setup () {
    if [ ${#logfile} -gt 1  ]; then
          touch "${logfile}"
          echo "GRUB-BTRFSD log $(date)" >> "${logfile}"
    fi

    if [ ${verbose} = true ]; then
          inotify_qiet_flag=""
    else
        inotify_qiet_flag=" -q -q "
    fi

    if [ ${recursive} = true ]; then
          inotify_recursive_flag=" -r "
    else
        inotify_recursive_flag=""
    fi

    if [ ${timeshift_auto} = true ]; then
          watchtime=15
          [ -d /run/timeshift ] || mkdir /run/timeshift
    else
        watchtime=0
    fi
}

function create_grub_menu () {
    #  create the grub submenu of the whole grub menu, depending on whether the submenu already exists
    #  and gives feedback if it worked
    if grep "snapshots-btrfs" "${GRUB_BTRFS_GRUB_DIRNAME:-/boot/grub}"/grub.cfg; then
    	  if  /etc/grub.d/41_snapshots-btrfs; then
		        log "Grub submenu recreated" "${GREEN}"
          else
		      err "[!] Error during grub submenu creation (grub-btrfs error)"
          fi
    else
        if ${GRUB_BTRFS_MKCONFIG:-grub-mkconfig} -o "${GRUB_BTRFS_GRUB_DIRNAME:-/boot/grub}"/grub.cfg; then
		      log "Grub menu recreated" "${GREEN}"
	    else
		    err "[!] Error during grub menu creation (grub/ grub-btrfs error)"
	    fi
    fi
}

function set_snapshot_dir () {
    # old timeshift has it's snapshot dir in a different location
    if [ "${timeshift_old}" = true ]; then
          snapdir="/run/timeshift/backup/timeshift-btrfs/snapshots"
    else
        snapdir="/run/timeshift/${timeshift_pid}/backup/timeshift-btrfs/snapshots"
    fi
}

function daemon_function () {
    trap 'vlog "$BASHPID: Received SIGINT/ SIGTERM"; exit 0' SIGINT SIGTERM
    # start the actual daemon
    snapdir=$1
    vlog "Subdaemon function started, PID: $BASHPID" "${GREEN}"
    vlog "${BASHPID}: Entering infinite while for $snapdir" "${GREEN}"
    vlog "${BASHPID}: Snapshot dir watchtimeout: $watchtime"
    while true; do
            runs=false
            if [ ${timeshift_auto} = true ] && ! [ "${timeshift_pid}" -gt 0 ] ; then
                  # watch the timeshift folder for a folder that is created when timeshift starts up
                  sleep 1 # for safety so the outer while is not going crazy
                  if [ "${timeshift_pid}" -eq -2 ]; then
                        log "${BASHPID}: detected timeshift shutdown"
                  fi
                  timeshift_pid=$(ps ax | awk '{sub(/.*\//, "", $5)} $5 ~ /timeshift/ {print $1}')
                  if [ "${#timeshift_pid}" -gt 0 ]; then
                        set_snapshot_dir
                        log "${BASHPID}: detected running Timeshift at daemon startup, PID is: $timeshift_pid"
                        vlog "${BASHPID}: new snapshots directory is $snapdir"
                  else
                      log "Watching /run/timeshift for timeshift to start"
                      inotifywait ${inotify_qiet_flag} -e create -e delete /run/timeshift && {
                          sleep 1
                          timeshift_pid=$(ps ax | awk '{sub(/.*\//, "", $5)} $5 ~ /timeshift/ {print $1}')
                          set_snapshot_dir
                          log "${BASHPID}: detected Timeshift startup, PID is: $timeshift_pid"
                          vlog "${BASHPID}: new snapshots directory is $snapdir"
                          (create_grub_menu) # create the grub menu once immediately in a forking process. Snapshots from commandline using timeshift --create need this
                      }
                  fi
                  runs=false
            else
                while [ -d "$snapdir" ]; do
                        # watch the actual snapshots folder for a new snapshot or a deletion of a snapshot
                        if [ ${runs} = false ] && [ ${verbose} = false ]; then
                              log "${BASHPID}: Watching $snapdir for new snapshots..."
                        else
                            vlog "${BASHPID}: Watching $snapdir for new snapshots..."
                        fi
                        runs=true
                        inotifywait ${inotify_qiet_flag} ${inotify_recursive_flag} -e create -e delete -e unmount -t "$watchtime" "$snapdir" && {
                            log "${BASHPID}: Detected snapshot creation/ deletion, recreating Grub menu"
                            sleep 5
                            create_grub_menu
                        }
                        sleep 1
                done
                timeshift_pid=-2
            fi
            if ! [ ${timeshift_auto} = true ] && ! [ -d "${snapdir}" ] ; then # in case someone deletes the snapshots folder (in snapper mode) to prevent the while loop from going wild
                  break
            fi
    done
}

set -eo pipefail

packageName="grub-btrfs"

# init
timeshift_pid=-1
watchtime=0
logfile=0
snapshots=-1
timeshift_auto=false
timeshift_old=false
verbose=false
syslog=false
recursive=false
trap sigHandler SIGINT SIGTERM

sysconfdir="/etc"
grub_btrfs_config="${sysconfdir}/default/grub-btrfsd"

# shellcheck disable=SC1090
test -f "$grub_btrfs_config" && . "$grub_btrfs_config"

# shellcheck disable=SC1091
test -f "${sysconfdir}/default/grub"  && . "${sysconfdir}/default/grub"

helpInfo="$(cat <<EOF
${packageName} - Update GRUB when new BTRFS snapshots are created.

Usage: [OPTIONS] SNAPSHOTS_DIRS

Optional arguments:
    -c, --no-color        Disable colors in output
    -l, --log-file        Specify a logfile to write to
    -r, --recursive       Watch snapshots directory recursively
    -s, --syslog          Write to syslog
    -o, --timeshift-old   Look for snapshots in directory of Timeshift <v22.06 (requires --timeshift-auto)
    -t, --timeshift-auto  Automatically detect Timeshifts snapshot directory
    -v, --verbose         Let the log of the daemon be more verbose
    -h, --help            Display this message

Version ${GRUB_BTRFS_VERSION}
EOF
)"

while getopts :l:otvrsh-: opt; do case "$opt" in
    -       )
        case "${OPTARG}" in
            log-file        ) logfile="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 )) ;;
            timeshift-auto  ) timeshift_auto=true                             ;;
            timeshift-old   ) timeshift_old=true                              ;;
            verbose         ) verbose=true                                    ;;
            recursive       ) recursive=true                                  ;;
            syslog          ) syslog=true                                     ;;
            help            ) echo "${helpInfo}" ; exit 0                     ;;
            *               )
                if test "$OPTERR" = "1" || test "${optspec:0:1}" = ":" ; then
                    err "[!] Non-option argument: '--${OPTARG}'" >&2
                    echo
                fi
                echo "${helpInfo}"
                exit 1
            ;;
        esac
    ;;
    l                       ) logfile="${OPTARG}"                             ;;
    t                       ) timeshift_auto=true                             ;;
    o                       ) timeshift_old=true                              ;;
    v                       ) verbose=true                                    ;;
    r                       ) recursive=true                                  ;;
    s                       ) syslog=true                                     ;;
    h                       ) echo "${helpInfo}" ; exit 0                     ;;
    *                       )
        if test "$OPTERR" = "1" || test "${optspec:0:1}" = ":" ; then
            err "[!] Non-option argument: '-${OPTARG}'" >&2
            echo
        fi
        echo "${helpInfo}"
        exit 1
    ;;
esac ; done

shift $(( OPTIND - 1 ))

snapdirs=( "${@}" )

vlog "Arguments:"
vlog "Snapshot directories: ${snapdirs[*]}"
vlog "Timestift autodetection: $timeshift_auto"
vlog "Timeshift old: $timeshift_old"
vlog "Logfile: $logfile"
vlog "Recursive: $recursive"

checks
setup

log  "grub-btrfsd starting up..."

if [ ${timeshift_auto} = true ] ; then
        daemon_function "timeshift" &
else
    # for all dirs that got passed to the script, start a new fork with that dir
    for snapdir in "${snapdirs[@]}"
        do
            vlog "starting daemon watching $snapdir..."
            daemon_function "${snapdir}" &
    done
fi
wait # wait for forks to finish, kill child forks if SIGTERM is sent
exit 0
